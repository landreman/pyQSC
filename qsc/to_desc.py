"""
This module contains the routines to output a
near-axis boundary to a DESC input file
"""
from datetime import datetime
import numpy as np
from .Frenet_to_cylindrical import Frenet_to_cylindrical
from .util import mu0, to_Fourier


def to_desc(self, filename, r=0.1, params=dict(), ntheta=21, ntorMax=14):
    """
    Outputs the near-axis configuration calculated with pyQSC to
    a text file that is able to be read by DESC.

    Args:
        filename: name of the text file to be created
        r:  near-axis radius r of the desired boundary surface
        params: a Python dict() instance containing one/several of the following parameters:
            L_rad, M_pol, N_tor, L_grid, M_grid, N_grid
            bdry_ratio, pres_ratio, pert_order
            ftol, xtol, gtol, nfev
            optimizer, objective, spectral_indexing, node_pattern
        ntheta: resolution in the poloidal angle theta for the Frenet_to_cylindrical calculation
        ntorMax: maximum number of N_tor in the resulting DESC input file

    """
    M_pol = params["M_pol"] if "M_pol" in params.keys() else int(np.floor(ntheta / 2))
    N_tor = params["N_tor"] if "N_tor" in params.keys() else int((self.nphi - 1) / 2)

    sym = int(not self.lasym)
    NFP = self.nfp
    Psi = np.pi * r ** 2 * self.spsi * self.Bbar

    p0 = -self.p2 * r ** 2  # pressure
    c0 = 2 * np.pi / mu0 * self.I2 * r ** 2  # toroidal current derivative

    # get surface shape
    R_2D, Z_2D, phi0_2D = self.Frenet_to_cylindrical(r, ntheta)
    # transform to VMEC Fourier coefficients
    RBC, RBS, ZBC, ZBS = to_Fourier(
        R_2D, Z_2D, self.nfp, np.max(M_pol), np.max(N_tor), self.lasym
    )
    # convert to DESC Fourier coefficients
    m_pol, n_tor, R_mn = ptolemy_identity(RBS, RBC)
    m_pol, n_tor, Z_mn = ptolemy_identity(ZBS, ZBC)

    # write to DESC file
    file_object = open(filename, "w+")
    file_object.write(
        "# This DESC input file was generated by pyQSC: github.com/landreman/pyQSC\n"
    )
    file_object.write(
        "# Date: {}, Time: {}, UTC {}\n".format(
            datetime.now().strftime("%B %d, %Y"),
            datetime.now().strftime("%H:%M:%S"),
            datetime.now().astimezone().strftime("%z"),
        )
    )
    file_object.write(
        "# Near-axis parameters:  radius r = {}, etabar = {}\n".format(r, self.etabar)
    )
    file_object.write(
        "# nphi = {}, order = {}, sigma0 = {}, I2 = {}, B0 = {}\n".format(
            self.nphi, self.order, self.sigma0, self.I2, self.B0
        )
    )
    file_object.write(
        "# Resolution parameters: ntheta = {}, ntorMax = {}\n".format(ntheta, ntorMax)
    )
    file_object.write("\n# global parameters\n")
    file_object.write("sym = {}\n".format(sym))
    file_object.write("NFP = {}\n".format(NFP))
    file_object.write("Psi = {:15.8E}\n".format(Psi))
    file_object.write("\n# spectral resolution\n")
    if "L_rad" in params.keys():
        file_object.write(
            "L_rad = " + " ".join(map(str, np.atleast_1d(params["L_rad"]))) + "\n"
        )
    file_object.write("M_pol = " + " ".join(map(str, np.atleast_1d(M_pol))) + "\n")
    file_object.write("N_tor = " + " ".join(map(str, np.atleast_1d(N_tor))) + "\n")
    if "L_grid" in params.keys():
        file_object.write(
            "L_grid = " + " ".join(map(str, np.atleast_1d(params["L_grid"]))) + "\n"
        )
    if "M_grid" in params.keys():
        file_object.write(
            "M_grid = " + " ".join(map(str, np.atleast_1d(params["M_grid"]))) + "\n"
        )
    if "N_grid" in params.keys():
        file_object.write(
            "N_grid = " + " ".join(map(str, np.atleast_1d(params["N_grid"]))) + "\n"
        )
    file_object.write("\n# continuation parameters\n")
    if "bdry_ratio" in params.keys():
        file_object.write(
            "bdry_ratio = "
            + " ".join(map(str, np.atleast_1d(params["bdry_ratio"])))
            + "\n"
        )
    if "pres_ratio" in params.keys():
        file_object.write(
            "pres_ratio = "
            + " ".join(map(str, np.atleast_1d(params["pres_ratio"])))
            + "\n"
        )
    if "pert_order" in params.keys():
        file_object.write(
            "pert_order = "
            + " ".join(map(str, np.atleast_1d(params["pert_order"])))
            + "\n"
        )
    file_object.write("\n# solver tolerances\n")
    if "ftol" in params.keys():
        file_object.write(
            "ftol = " + " ".join(map(str, np.atleast_1d(params["ftol"]))) + "\n"
        )
    if "xtol" in params.keys():
        file_object.write(
            "xtol = " + " ".join(map(str, np.atleast_1d(params["xtol"]))) + "\n"
        )
    if "gtol" in params.keys():
        file_object.write(
            "gtol = " + " ".join(map(str, np.atleast_1d(params["gtol"]))) + "\n"
        )
    if "nfev" in params.keys():
        file_object.write(
            "nfev = " + " ".join(map(str, np.atleast_1d(params["nfev"]))) + "\n"
        )
    file_object.write("\n# solver methods\n")
    if "optimizer" in params.keys():
        file_object.write("optimizer = {}\n".format(params["optimizer"]))
    if "objective" in params.keys():
        file_object.write("objective = {}\n".format(params["objective"]))
    if "spectral_indexing" in params.keys():
        file_object.write(
            "spectral_indexing = {}\n".format(params["spectral_indexing"])
        )
    if "node_pattern" in params.keys():
        file_object.write("node_pattern = {}\n".format(params["node_pattern"]))
    file_object.write("\n# pressure and current profiles\n")
    file_object.write("l: {:3d}  p = {:15.8E}  c = {:15.8E}\n".format(0, p0, 0))
    file_object.write("l: {:3d}  p = {:15.8E}  c = {:15.8E}\n".format(2, -p0, c0))
    file_object.write("\n# magnetic axis initial guess\n")
    for n in range(self.zs.size - 1, 0, -1):
        file_object.write(
            "n: {:3d}  R0 = {:15.8E}  Z0 = {:15.8E}\n".format(
                -n, self.rs[n], self.zs[n]
            )
        )
    for n in range(self.rc.size):
        file_object.write(
            "n: {:3d}  R0 = {:15.8E}  Z0 = {:15.8E}\n".format(n, self.rc[n], self.zc[n])
        )
    file_object.write("\n# fixed-boundary surface shape\n")
    for k in range(len(m_pol)):
        file_object.write(
            "m: {:3d}\tn: {:3d}\tR1 = {:15.8E}\tZ1 = {:15.8E}\n".format(
                int(m_pol[k]), int(n_tor[k]), R_mn[k], Z_mn[k]
            )
        )
    file_object.close()


def ptolemy_identity(s, c):
    """Convert from double-angle to double-Fourier form using Ptolemy's identity.

    Converts from the double-angle form (VMEC convention):
        s*sin(m*theta-n*phi) + c*cos(m*theta-n*phi)
    to a double Fourier series of the form (DESC convention):
        ss*sin(m*theta)*sin(n*phi) + sc*sin(m*theta)*cos(n*phi) +
        cs*cos(m*theta)*sin(n*phi) + cc*cos(m*theta)*cos(n*phi)
    using Ptolemy's sum and difference formulas.

    Parameters
    ----------
    s : ndarray, shape(2*ntor+1,mpol), optional
        Coefficients of sin(m*theta-n*phi) terms.
    c : ndarray, shape(2*ntor+1,mpol), optional
        Coefficients of cos(m*theta-n*phi) terms.

    Returns
    -------
    m : ndarray, shape(num_modes,)
        Poloidal mode numbers of the double Fourier basis.
    n : ndarray, shape(num_modes,)
        Toroidal mode numbers of the double Fourier basis.
    x : ndarray, shape(num_modes,)
        Spectral coefficients in the double Fourier basis.

    """
    s = np.atleast_2d(s)
    c = np.atleast_2d(c)
    if np.prod(s.shape) == 1:
        s = np.zeros_like(c)
    if np.prod(c.shape) == 1:
        c = np.zeros_like(s)

    M = int(s.shape[1] - 1)
    N = int((s.shape[0] - 1) / 2)

    m_pol = np.arange(M + 1)
    n_tor = np.arange(-N, N + 1)

    mn = np.array([[m - M, n - N] for m in range(2 * M + 1) for n in range(2 * N + 1)])
    m = mn[:, 0]
    n = mn[:, 1]

    x = np.zeros(((2 * M + 1) * (2 * N + 1),))

    for i, n_i in enumerate(n_tor):
        for j, m_j in enumerate(m_pol):
            # sin(m*theta)*cos(n*phi) index
            sin_cos = np.where((mn == [-np.abs(m_j), np.abs(n_i)]).all(axis=1))[0][0]
            # cos(m*theta)*sin(n*phi) index
            cos_sin = np.where((mn == [np.abs(m_j), -np.abs(n_i)]).all(axis=1))[0][0]
            # cos(m*theta)*cos(n*phi) index
            cos_cos = np.where((mn == [np.abs(m_j), np.abs(n_i)]).all(axis=1))[0][0]
            # sin(m*theta)*sin(n*phi) index
            sin_sin = np.where((mn == [-np.abs(m_j), -np.abs(n_i)]).all(axis=1))[0][0]
            # set coefficients
            if np.sign(m_j) != 0:
                x[sin_cos] += s[i, j]
            x[cos_cos] += c[i, j]
            if np.sign(n_i) > 0:
                x[cos_sin] -= s[i, j]
                if np.sign(m_j) != 0:
                    x[sin_sin] += c[i, j]
            elif np.sign(n_i) < 0:
                x[cos_sin] += s[i, j]
                if np.sign(m_j) != 0:
                    x[sin_sin] -= c[i, j]

    return m, n, x
